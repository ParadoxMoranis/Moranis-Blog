<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>正则表达式 | Moranis-Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="正则表达式
很久没写笔记了，写点正则表达式吧

图片来自bilibili：geekhour
工具

一些在线工具
VSCode也提供了对正则表达式的支持，快捷键ctrl&#43;F

构成
正则表达式通常是由两个斜线包裹起来的，
后面可以跟上一些修饰符。
例如：">
    <meta name="generator" content="Hugo 0.143.1">
    
    
    
      <meta name="robots" content="index, follow">
    
    <meta name="author" content="Moranis">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css" >




    

    
      
<link rel="shortcut icon" href="/images/bochi-git.jpg" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="https://moranis.netlify.app/posts/regex/">
    

    <meta property="og:url" content="https://moranis.netlify.app/posts/regex/">
  <meta property="og:site_name" content="Moranis-Blog">
  <meta property="og:title" content="正则表达式">
  <meta property="og:description" content="正则表达式 很久没写笔记了，写点正则表达式吧
图片来自bilibili：geekhour
工具 一些在线工具 VSCode也提供了对正则表达式的支持，快捷键ctrl&#43;F 构成 正则表达式通常是由两个斜线包裹起来的，
后面可以跟上一些修饰符。
例如：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-24T19:02:17+08:00">
    <meta property="article:modified_time" content="2024-09-24T19:02:17+08:00">
    <meta property="article:tag" content="Regex">
    <meta property="article:tag" content="Vscode">

  <meta itemprop="name" content="正则表达式">
  <meta itemprop="description" content="正则表达式 很久没写笔记了，写点正则表达式吧
图片来自bilibili：geekhour
工具 一些在线工具 VSCode也提供了对正则表达式的支持，快捷键ctrl&#43;F 构成 正则表达式通常是由两个斜线包裹起来的，
后面可以跟上一些修饰符。
例如：">
  <meta itemprop="datePublished" content="2024-09-24T19:02:17+08:00">
  <meta itemprop="dateModified" content="2024-09-24T19:02:17+08:00">
  <meta itemprop="wordCount" content="1389">
  <meta itemprop="keywords" content="Regex,Vscode">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="正则表达式">
  <meta name="twitter:description" content="正则表达式 很久没写笔记了，写点正则表达式吧
图片来自bilibili：geekhour
工具 一些在线工具 VSCode也提供了对正则表达式的支持，快捷键ctrl&#43;F 构成 正则表达式通常是由两个斜线包裹起来的，
后面可以跟上一些修饰符。
例如：">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

  
  
  
  <header class="cover bg-center" style="background-image: url('https://moranis.netlify.app/image/regex.png');">
    <div class="bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Moranis-Blog
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/" title="首页 页">
              首页
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/posts/" title="文章 页">
              文章
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="关于 页">
              关于
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

      <div class="tc-l pv6 ph3 ph4-ns">
        
          <div class="f2 f1-l fw2 white-90 mb0 lh-title">正则表达式</div>
          
        
      </div>
    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">正则表达式</h1>
      
      <p class="tracked"><strong>Moranis</strong>
      </p>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2024-09-24T19:02:17+08:00">九月 24, 2024</time>
      

      
      
        <span class="f6 mv4 dib tracked"> -  </span>
        <span class="f6 mv4 dib tracked"> -  </span>
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="正则表达式">正则表达式</h1>
<p>很久没写笔记了，写点正则表达式吧</p>
<p><img src="/image/regex.png" alt="正则"></p>
<p>图片来自bilibili：geekhour</p>
<h2 id="工具">工具</h2>
<ul>
<li>一些在线工具</li>
<li>VSCode也提供了对正则表达式的支持，快捷键ctrl+F</li>
</ul>
<h2 id="构成">构成</h2>
<p>正则表达式通常是由两个斜线包裹起来的，<br>
后面可以跟上一些修饰符。<br>
例如：</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/([A-Z])\w+/g
</code></pre><p>g表示global(全局)<br>
其他的，例如小写字母i表示忽略大小写<br>
m表示多行匹配等等</p>
<h2 id="符号">.符号</h2>
<p>.符号可以表示某部分任意位置的字符串并进行匹配<br>
例如：</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/.at/g
</code></pre><p>那么所有的&quot;*at&quot;字符串将被匹配<br>
例如create中的eat将被匹配</p>
<h2 id="字符集合">[]字符集合</h2>
<h3 id="特定字符">特定字符</h3>
<p>如果只想找到at后面的c或者e<br>
那就可以使用字符集合</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at[ce]/g
</code></pre><p>这样就可以匹配到所有的atc和ate<br>
数字也可以使用</p>
<h3 id="范围">范围</h3>
<p>此外，[]中还可以使用范围</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at[a-z]/g
</code></pre><p>这样就可以匹配at后面跟着小写字母的字符串<br>
还可以加入更多范围</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at[a-zA-Z1-3]/g
</code></pre><p>这样，atA,atB&hellip;at1,at2,at3也会匹配到</p>
<h3 id="取反">^取反</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at[^A-Z]/g
</code></pre><p>这就表示匹配除了at后面跟着大写字母的at*字符串<br>
注：^必须在方括号内部才表示取反，在外部表示匹配每一行的开头</p>
<h3 id="预定义字符类">预定义字符类</h3>
<p>每次使用方括号可能会非常繁琐，<br>
所以正则表达式提供了一些预定义字符。<br>
例如\d表示数字，和[0-9]是一样的。</p>
<ul>
<li>\D表示非数字</li>
<li>\w表示字母，数字或者下划线</li>
<li>\W表示与w相反的范围</li>
<li>\s表示空白字符，也就是空格或者Tab</li>
<li>\S表示非空白字符</li>
</ul>
<h2 id="位置和边界匹配">位置和边界匹配</h2>
<h3 id="符号-1">^符号</h3>
<p>^匹配每行的开头<br>
例如：/^a/g<br>
就会找到每段开头为a的字符串，不会匹配到段落内部<br>
/^a/gm<br>
加上m表示多行匹配，就可以匹配到每一行的开头的字母a了</p>
<h3 id="符号-2">$符号</h3>
<p>$表示匹配每一行的结尾<br>
比如我们想要找到一片英语文章中的所有以句号结尾的部分，<br>
就可以在.后面加上$<br>
/.$/gm<br>
表示.之后就是这一行的结尾。<br>
但是除了点号之外其他字符也被匹配到了。<br>
那么只需要加一个反斜线来转义一下。<br>
/.$/gm<br>
这样就不会匹配其他字符了。</p>
<h3 id="b">\b</h3>
<p>\b表示单词边界</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/\bin/gm
</code></pre><p>这个正则表达式将匹配文本中的开头的in<br>
\b放在in后面则会匹配末尾的in<br>
在in前后都加上\b则会匹配单独的单词in<br>
\B表示相反的含义，即非边界</p>
<h2 id="量词">量词</h2>
<p>顾名思义，量词是用来表示重复次数的。</p>
<h3 id="符号-3">+符号</h3>
<p>想要找a后面有一个或多个t的字符串，<br>
就可以在t后面加上一个+。</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">    /at+/gm
</code></pre><h3 id="符号-4">*符号</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at*/gm
</code></pre><p>无论a后面有没有t，有多少个t，都会被匹配到。</p>
<h3 id="符号-5">?符号</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at?/gm
</code></pre><p>只有a或者at会被匹配到。</p>
<h3 id="指定次数">{}指定次数</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at{3}/gm
</code></pre><p>这样，只有a后面是三个t的字符串会被匹配。<br>
此外，{}还可以指定范围，使用逗号隔开。</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at{3,5}/gm
</code></pre><p>这样，只有a后面是三到五个t的字符串会被匹配。</p>
<h2 id="贪婪匹配">贪婪匹配</h2>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at{3,}/gm
</code></pre><p>这里表示t至少重复3次。但是更多次数的也会匹配到。<br>
这种匹配模式成为贪婪匹配。</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/at{3,}?/gm
</code></pre><p>加个问号，就会在重复三次后停止匹配。<br>
这就是非贪婪匹配。</p>
<h2 id="分组和引用">分组和引用</h2>
<h3 id="分组">()分组</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/(at)*/gm
</code></pre><p>括号内部的字符串将被视为整体处理。<br>
这个正则表达式将会匹配多次重复的at.</p>
<h3 id="分组-1">[]分组</h3>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/[Pp]attern/gm
</code></pre><p>当我们想要匹配一个单词，且无论首字母大小写。<br>
就可以将大写和小写字母用[]括起来。</p>
<h3 id="或者">|或者</h3>
<p>对于上一个情况，还可以使用|符号</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/Pattern|pattern/gm
</code></pre><p>这也可以实现上一个要求。</p>
<h3 id="和结合">()和|结合</h3>
<p>写两边这个单词未免太麻烦了，不妨分组处理大小写</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/(P|p)attern/gm
</code></pre><p>它和上面的两条起同样的作用。</p>
<h3 id="多个分组">多个分组</h3>
<p>给定一个场景，我们要提取日期，就可以分组分别提取年月日。
2024-05-01<br>
2024-05-02<br>
2024-05-03<br>
2024-05-04<br>
2024-05-05</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/\d{4}-\d{1,2}-\d{1,2}/gm
</code></pre><p>如果我们要改为月日年的格式，就需要创建三个分组。</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/(\d{4})-(\d{1,2})-(\d{1,2})/gm
</code></pre><p>打开替换框 输入：$2-$3-$1<br>
他们三个分别表示第一个分组，第二个分组第三个分组。</p>
<p>但是期起会有很多格式，比如 ：<br>
2024-05-01<br>
2024/05/02<br>
2024_05_03<br>
2024.05.04<br>
20240505</p>
<p>那我们就可以修改正则表达式为：</p>
<pre tabindex="0"><code class="language-regex" data-lang="regex">/(\d{4})[-/._]?(\d{1,2})[-/._]?(\d{1,2})/gm
</code></pre><p>这样就可以匹配所有日期的时间了。</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/regex/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Regex</a>
   </li>
  
   <li class="list di">
     <a href="/tags/vscode/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Vscode</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://moranis.netlify.app/" >
    &copy;  Moranis-Blog 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
